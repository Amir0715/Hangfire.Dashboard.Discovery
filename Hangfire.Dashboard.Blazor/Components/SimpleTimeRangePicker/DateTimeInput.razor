<style>
    .date-time-input {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }

    .input-field {
        padding: 0.5rem;
        background: #2d333b;
        border: 1px solid #444c56;
        border-radius: 4px;
        color: #adbac7;
    }
</style>

<div class="date-time-input">
    <label>@Label</label>
    <input type="datetime-local"
           class="input-field"
           value="@_localValue"
           @onchange="@(args => HandleInput(args.Value?.ToString()))"/>
    @if (!string.IsNullOrEmpty(_error))
    {
        <div class="text-danger">@_error</div>
    }
</div>

@code {

    [Parameter]
    public string Label { get; set; }

    [Parameter]
    public DateTimeOffset? Value { get; set; }

    [Parameter]
    public EventCallback<DateTimeOffset?> ValueChanged { get; set; }

    [Inject]
    public BrowserTimeService BrowserTimeService { get; set; } = null!;

    private string _localValue = string.Empty;
    private string? _error;
    private const string DateTimeLocalHtmlInputFormat = "yyyy-MM-ddTHH:mm";

    protected override async Task OnParametersSetAsync()
    {
        if (Value.HasValue)
        {
            var browserDateTime = await BrowserTimeService.ToBrowserDateTimeAsync(Value.Value);
            _localValue = browserDateTime.ToString(DateTimeLocalHtmlInputFormat);
        }
    }

    private async Task HandleInput(string? newValue)
    {
        if (_localValue == newValue) return;
        
        // В newValue будет лежать локальное время пользователя
        if (DateTime.TryParse(newValue, out var dateTime))
        {
            _error = null;
            _localValue = newValue;
            var browserDateTimeOffset = await BrowserTimeService.FromBrowserDateTimeAsync(dateTime);
            await ValueChanged.InvokeAsync(browserDateTimeOffset);
        }
        else
        {
            _error = "Invalid date format";
        }
    }

}